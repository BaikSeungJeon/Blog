# VueJS

## Vue 라이프사이클

<code>created</code>와 <code>mounted</code>의 차이에 대해 알아보려 합니다. 보통 컴포넌트 접속 시 GET으로 axios 요청해 리스트 데이터를 받아와 뿌릴 때, axios를 요청하는 함수를 생성한 뒤, <code>mounted</code>에서 해당 함수를 실행해 줬습니다. 왜냐하면 <code>mounted</code>는 컴포넌트가 DOM에 추가돼 렌더링 된 후 실행되기 때문에, 컴포넌트가 렌더링 후 필요한 추가 작업들을 수행할 수 있어, 컴포넌트 접속 시 최초 1회 리스트를 바로 제공할 수 있었기 때문입니다.

하지만 <code>created</code> 또한 앞에서 말한 내용들을 수행하기에 적합한 Vue.js 생명주기의 단계입니다. 그렇다면 이 둘의 단계는 어떤 차이점이 있는 것일까요?

### created

<code>created</code>는 컴포넌트가 생성된 후, template과 data 속성들이 초기화 된 이후에 실행됩니다. 따라서 이 단계에서는 DOM 요소에 직접 접근할 수 없습니다. 단 이 단계에서는 컴포넌트의 속성들과 이벤트 등록, 비동기 처리 등을 수행할 수 있습니다.

### mounted

<code>mounted</code>는 위에서 말했다시피 컴포넌트가 DOM에 추가되어 렌더링 된 이후에 실행됩니다. 따라서 이 단계에서는 DOM 요소에 접근할 수 있습니다. 주로 외부 라이브러리와의 연동, 컴포넌트가 렌더링 된 이후에 필요한 추가 작업들을 수행할 수 있습니다.

즉 이 둘은 DOM에 접근할 수 있냐 없냐가 가장 큰 차이인데, <code>created</code> 단계에서는 DOM이 아직 렌더링되지 않았기 때문에 template이나 data 속성 등을 초기화 하는 작업을 수행할 수 있습니다. DOM에 접근하거나 렌더링 이후 필요한 작업들은 <code>mounted</code>에서 수행해주는 것이 적합합니다.

그런 의미에서, 컴포넌트에 접속해 최초 1회 GET 요청으로 데이터를 가져와 제공한다면, <code>mounted</code>에서 함수를 호출하는 것이 적합합니다. <code>created</code> 단계에서 데이터를 가져오는 경우, 컴포넌트에서 사용하는 데이터가 로드 되기 전에 렌더링 될 가능성이 있어, 에러가 발생할 수 있는 반면, <code>mounted</code> 단계에서는 컴포넌트가 렌더링 된 이후 호출되기 때문에 렌더링 에러가 발생하지 않습니다.

이는 Vue.js의 생명주기에서 <code>created</code> 단계에서 컴포넌트가 생성 및 template과 data 속성 초기화. 이어서 DOM 렌더링이 이루어지고, <code>mounted</code> 단계에서 컴포넌트가 DOM에 추가돼 렌더링 된 후 실행되는 것을 생각해 보면 쉽게 이해할 수 있습니다.

## 데이터 가공

가령 이미지에 마우스 오버를 해 상세설명 텍스트가 출력을 하거나 댓글을 수정할 때가 있을 것입니다. 이미지와 댓글 등은 서버로부터 받아온 데이터를 Vue.js에서는 <code>v-for</code> 디렉티브를 사용해 제공합니다. 하지만 이렇게 받아온 데이터에 무턱대고 위에서 언급한 기능을 하게 되면 이미지 전체에 대한 상세설명 텍스트가 출력되거나 받아온 댓글들 전부가 수정이 될 것입니다.

이런 경우, 이벤트를 수행하는 메서드에 클릭이나 마우스 오버 시 해당 이미지나 댓글에 대한 인덱스를 매개변수로 보내줘야 하며, 보통 이런 기능의 경우 <code>true</code> 혹은 <code>false</code>에 따라 UI를 다르게 제공하기 때문에, 받아온 객체 형태 데이터 중 이미지 상세설명이면 상세설명, 댓글 수정모드면 수정모드에 따른 boolean 값을 가지고 있는 데이터가 필요합니다.

이런 경우 초기 데이터베이스 설계 시 고려되지 않고 보통 프론트엔드에서 백엔드로부터 API를 받아와 가공하거나, 프론트엔드에서 요청 시 필요한 데이터를 백엔드에서 가공 후 전달합니다. 효율적인 측면에서는 백엔드에서 API를 가공해 프론트엔드로 전달하는 것이 낫다고 합니다. 왜냐하면 데이터 전송 양이 줄어들기 때문입니다. 물론 프론트엔드에서 데이터를 받아와 가공하는 것은 가능하지만 과정 속에서 중복되는 데이터가 많아질 수 있습니다. 이런 중복 데이터는 네트워크 트래픽을 불필요하게 증가시키고 성능을 저하시킬 수 있습니다. 그리고 백엔드에서 가공된 데이터는 일관성이 유지됩니다.

물론 상황에 맞게 사용하는 것이 중요합니다. 지금처럼 단순히 true/false 값만 추가하는 경우는 데이터 전송 양이 크게 증가하지 않겠지만 일관성과 유지보수 측면에서는 여전히 백엔드에서 가공해 API를 제공하는 것이 좋을 수 있습니다. 하지만 지금처럼 이미 GET 요청으로 받아온 댓글 데이터를 프론트엔드에서 map 함수를 통해 필요한 값만 추가하는 경우는 별도의 API 호출을 또 하지 않아도 돼 해당 방법이 더 나을 수도 있습니다.

아래는 코드입니다.

```html
<script>
  const baseUrl = process.env.VUE_APP_API_URL;

  export default {
    methods: {
      getComment(){
        this.$axios.get(
          `${baseUrl}/article/photo/${this.articlePnum}/comment/`
        ).then(res => {
          this.commentData = res.data.map(comment => ({
            ...comment,
            isEditMode: false
          }))
          this.commentLen = this.commentData.length;
        }).catch(err => {
          console.log("[DetailPhoto GET COMMENT] ", err);
        })
      },
    }
  }
</script>
```