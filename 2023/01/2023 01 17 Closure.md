<code>Closure</code>는 함수와 함수가 선언된 어휘적 환경의 조합입니다. 먼저 클로저를 알기 전에 <code>Scope</code>와, <code>Lexical Scope</code>에 대한 이해가 필요합니다.

### Scope

#### Scope

[이전 작성 글](https://github.com/BaikSeungJeon/TIL/blob/main/2022/10/2022%2010%2022%20Scope%20%26%20Tree%20Shaking.md)

```js
var x = 'global';

function foo () {
  var x = 'function scope';
  console.log(x);
}

foo(); // function scope 출력
console.log(x); // global 출력
```

위 예제에서 전역에 선언된 변수 x(global)는 어디에든 참조할 수 있습니다. 하지만 함수 foo 내에서 선언된 변수 x는 함수 foo 내부에서만 참조할 수 있고 함수 외부에서는 참조할 수 없습니다. 이러한 규칙을 <code>Scope</code>라고 합니다.

만약 스코프가 없다면 어떻게 될까요? 스코프가 없다면 같은 식별자 이름은 충돌을 일으키므로 프로그램 전체에서 하나밖에 사용할 수 없습니다. 가령 디렉터리가 없는 
컴퓨터를 생각해 보면, 디렉터리가 없다면 같은 이름을 갖는 파일을 하나밖에 만들 수 없을 것입니다. 스코프도 이와 같이 식별자 이름의 충돌을 방지합니다.

#### lexical scope

```js
var x = 1;

function foo() {
  var x = 10;
  bar();
}

// 전역
function bar() {
  console.log(x); 
}

foo(); // 1
bar(); // 1
```

결론적으로 <code>foo()</code>와, <code>bar()</code>를 호출 시, 둘 다 <code>1</code>이 출력됩니다.

두가지 패턴을 예측할 수 있습니다. 첫번째는 함수를 어디서 '호출'했는지에 따라 상위 스코프를 결정하는 것과, 두번째는 
함수를 어디서 '선언'하였는지에 따라 상위 스코프를 결정하는 것입니다.

첫번째 방식(= 어디서 호출)으로 함수의 상위 스코프를 결정한다면 함수 <code>bar()</code>의 상위 스코프는 함수 <code>foo()</code>와 전역일 것이고,
두번째 방식(= 어디서 선언)으로 함수의 스코프를 결정한다면, 함수 <code>bar()</code>의 상위 스코프는 전역일 것입니다.

프로그래밍 언어는 이 두가지 방식 중 하나의 방식으로 함수의 상위 스코프를 결정하는데, 첫번째 방식을 <code>동적 스코프(Dynamic scope)</code>라 하고,
두번째 방식을 <code>렉시컬 스코프(Lexical scope)</code> 또는 <code>정적 스코프(Static scope)</code>라 합니다.

함수형 언어인 자바스크립트에서는 렉시컬 스코프를 따릅니다. 즉, 앞서 말한 것처럼 렉시컬 스코프는 함수를 '어디서 호출'하는지가 아니라 '어디에 선언'하였는지에 따라 결정되기 때문에 <code>bar()</code>는 전역에 선언됐기 때문에 1이 출력되는 것입니다.

다시 돌아와 <code>foo()</code> 실행 시, <code>x</code>에 10이 재할당 되고, 그 상태에서 함수 <code>bar()</code>를 호출하니 
<code>10</code>이 출력될 줄 알았지만, 앞서 말한 대로, <code>bar()</code>가 호출(함수 <code>foo()</code> 하위에서)되는 위치가 아닌, 선언된 위치를 따르기 때문에 바로 상위의 전역 변수 <code>x = 1</code>를 출력하는 것입니다.

---

### Closure
> 함수와 그 함수가 선언된 Lexical 환경의 조합
