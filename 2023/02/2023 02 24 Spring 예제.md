## 목차
- [log4j](#log4j)
- [@Controller](#controller)
- [@RequestMapping](#requestmapping)
- [InternalResourceView Class](#internalresourceview-class)
- [Model & ModelAndView Calss](#model-modelandview-class)
- [EL(Expression Language)](#el-expression-language)

## log4j
> log4j를 사용해 보자

콘솔에 <code>System.out.println()</code>을 이용해 출력하는 건 여러가지 측면에서 좋지 않습니다. 하지만 자바 개발을 입문하면서, 데이터의 흐름을 파악하거나 디버깅을 할 만한 방법이 없기 때문에 어쩔 수 없이 사용했지만 이제는 다음과 같은 이유로 사용을 지양할 필요가 있습니다.

1. 성능 면에서 좋지 않다
2. 관리적인 측면에서도 좋지 않다
  - 최종적으로 전부 찾아 지워야 하는데, 매우 번거로움
3. 결정적으로 운영 시 log 생성이 필수다

스프링에서는 <code>log4j</code>를 쉽게 이용할 수 있습니다. 우리가 사용할 버전은 <code>log4j 1.x.x</code> 버전을 사용할 것이며, 후에 확장 버전으로 <code>log4j 2.x.x</code>을 변경할 것입니다. 스프링 부트에서는 <code>logback</code> 사용이 가능한데, 저희는 현재 스프링 부트를 사용하지 않기 때문에 이는 스킵하도록 하겠습니다.

<code>log4j</code>는 <code>log4j.xml</code>이라는 설정 파일이 있습니다. 이 설정 파일의 위치는 <code>src/main/resources</code> 경로 안에 존재합니다.

### log4j의 xml 태그들
> xml 파일 안에 눈 여겨 봐야 할 중요한 태그 세 가지가 존재한다

#### appender
> log의 출력 위치를 지정

```xml
<!-- log4j.xml -->

<!-- name은 내가 원하는 대로 지정 -->
<appender name="console" class="org.apache.log4j.ConsoleAppender">
  <!-- param 중요 -->
  <param name="Target" value="System.out" />

  <!-- layout의 역할은 log의 출력 형태를 지정 -->
  <!-- 단순 메시지만 출력할 것인지, 날짜와 같이 찍을 것인지, 
  클래스와 같이 찍을 것인지 등의 부가적인 정보, 모양 등을 지정 -->
  <layout class="org.apache.log4j.PatternLayout">
    <param name="ConversionPattern" value="%-5p: %c - %m%n" />
  </layout>
</appender>
```

<code>appender</code>는 종류가 여러 개가 있습니다.

- Console Appender
  - console
- File Appender
  - File
- RollingFile Appender
  - 용량 제한 File
- Daily Rolling Appender
  - 날짜 별로 File

<code>Console Appender</code>와 <code>Daily Rolling Appender</code>를 많이 사용합니다.

#### layout
> layout의 역할은 log의 출력 형태를 지정

- %p
  - 로그 레벨을 같이 출력
- %m
  - 로그 메시지 출력
- %d
  - 로그 발생 시간 출력
    - yyyy-mm-dd HH:mm:ss
- %c
  - 어떤 파일에서 작성했는지 출력

#### logger
> 메시지를 appender에 전달하는 역할 수행
>> log의 출력 레벨에 따라 출력 여부 결정(레벨은 총 6단계)

```xml
<!-- log4j.xml -->
<logger name="org.springframework.core">
  <level value="info" />
</logger>
```

로그 레벨 6단계
- FATAL
  - 가장 높은 단계
  - 시스템의 심각한 문제가 있음을 의미
- ERROR
  - 실행 중 ERROR가 발생
- WARN
  - 오류의 원인이 될 수 있는 메시지 출력
- INFO
  - application 운영 -> 운영 레벨
    - info() 메서드 존재 
- DEBUG
  - 개발 시 디버깅 용도
    - sysout 대신 사용함
    - debug() 메서드 존재
- TRACE
  - DEBUG의 상세 버전 

<code>log4j.xml</code> 안 <code>logger</code> 태그에서 <code>logger level</code>을 지정 시, 지정한 <code>logger level</code>보다 하위 레벨은 찍히지 않습니다. 따라서 개발 시 레벨을 <code>DEBUG</code>로 지정해 버그를 추적하고, 운영 시 레벨을 <code>INFO</code>로 변경하면, 개발 시 찍어놨던 로그가 출력이 되지 않으며 이를 일일이 지워야 하는 수고도 덜 수 있습니다.

```xml
<logger name="my.spring.springweb">
  <level value="info" />
  <!-- 이런 경우, 로그 레벨이 info보다 하위 레벨은 출력되지 않음 -->
  <!-- 예를 들어, logger.debug() 사용해도 안 나옴 -->
  <!-- 즉, level을 하위 레벨로 잡아 디버그 메시지를 출력하다,
  운영 시 로그의 레벨을 상위 레벨로 지정해주면 출력되지 않음 -->
</logger>
```

## Controller
> 특정 클래스가 컨트롤러 역할을 하는 Bean임을 나타내는 어노테이션

## RequestMapping

```java
@RequestMapping(value="url path")
```

### TestController01
> @Controller와 @RequestMapping 학습

```java
// TestController01.java

package my.spring.springweb.sample01;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class TestController01 {
	// 로그를 출력할 수 있는 객체가 있어야 함
	// LoggerFactor에서 .getLogger 메서드를 통해 끌어다 씀
	// 인자에는 문자열이 아니라 클래스 입력
	private static final Logger logger = LoggerFactory.getLogger(TestController01.class);
	
	// http://localhost:8080/springweb
	// value 안에 'springweb/' 경로 뒤에 나올 경로를 지정
	// 참고로 경로는 그냥 자유롭게 작성 가능. 지금은 편의를 위해 클래스 명을 따라간 것
	@RequestMapping(value = "/testController01", method=RequestMethod.GET)
	String myMethod() {
		// 개발 할 땐 debug를 사용하는 게 좋음
		// 그래야 추후 운영 시 log4j.xml에서
		// log 레벨을 degub -> info로 변경하면 아무것도 출력 안 되기 때문
		logger.debug("hello world");
		
		// 내가 결과를 보여줄 json을 문자열로 리턴
		return "sample01/testController01";
	}
}
```

```jsp
<!-- testController01.jsp -->

<%@ page language="java" contentType="text/html; charset=UTF-8"
	pageEncoding="UTF-8"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<!DOCTYPE html>
<html>
  <head>
  <meta charset="UTF-8">
  <title>Insert title here</title>
  </head>
  <body>
    hello world!
  </body>
</html>
```

URL 접속 시 다음과 같이 출력됩니다.

<img src="스크린샷 2023-02-24 오후 1.46.51.png" />

### sample01/TestController02
> 경로 계층 구조로 작성

```java
// TestController02.java

package my.spring.springweb.sample01;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

// 컨트롤러로 만들 것
@Controller
@RequestMapping("/testController02") // requestMapping이 두 개 필요하면 공통된 부분을 계층 구조로 만들 수 있음
// 예를 들면, /testController02/info와, /testController02/profile에서, /testController02를 가장 상위에 작성

public class TestController02 {
	
	private static final Logger logger = LoggerFactory.getLogger(TestController02.class);
	
	@RequestMapping("/info")
	String myMethod0201() {
		logger.debug("hello world ");
		
		return "sample01/testController02";
	}
	
	@RequestMapping("/profile")
	String myMethod0202() {
		logger.debug("hello world");
		
		return "sample01/testController02";
	}
	
	// 이처럼 객체로 매핑도 가능함
	@RequestMapping(value = {"", "/test01", "/test02", "/test03/*"})
	String myMethod0203() {
		logger.debug("hello world");
		
		return "sample01/testController02";
	}
}

```

URL 접속 시 다음과 같이 출력됩니다.

### sample01/TestController05
> GetMapping(params="") 사용

```java
// TestController05.java

package my.spring.springweb.sample01;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
@RequestMapping(value="/testController05")
public class TestController05 {
	
	private static final Logger logger = LoggerFactory.getLogger(TestController05.class);
	
	// param 값 있을 때에만 호출
  // params="myName"라 지정하면,
  // http://localhost:8080/springweb/testController05?myName=백승전
  // 과 같이 get 요청을 보내면 정상 출력 된다
	@GetMapping(params="myName")
	String myMethod0501() {
		logger.debug("testController05 호출");
		return "sample01/testController05";
	}
}
```

URL 접속 시 다음과 같이 출력됩니다.

## InternalResourceView Class

## Model ModelAndView Class

### sample01/TestController07
> Model 사용

```java
// TestController07.java

package my.spring.springweb.sample01;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping("/testController07")
public class TestController07 {
	private static final Logger logger = LoggerFactory.getLogger(TestController07.class);
	
	@GetMapping
	public String MyMethod(Model model) {
		// Model 안에 담아 렌더링 해 출력
		// ApplicationContext에 의해 Model 객체가 주입됨
		
		logger.debug("testController07이 호출됨");
		
		// 모델 객체에 데이터를 실어줄 건데,
		// 모델은 Map으로 돼 있음
		// key: value 형태로 데이터를 저장
		
		// setAttribute 아님
		model.addAttribute("myName", "백승전");
		model.addAttribute("myAge", 100);
		
		// testController07.jsp로 이동
		return "sample01/testController07";
	}
}
```

```jsp
<!-- testController07.jsp -->

<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
    <%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<h1>testController07 호출</h1>

	
	<!-- 모델 안에 저장돼 있는 데이터를 들고와 여기서 출력해야 됨 -->
	<!-- 출력을 하기 위해 기존 JSP의 표현식과 비슷한 EL을 사용할 것 -->

	<!--	EL의 데이터 표기 방식 ${ } -->
  <!-- 참고로 html이 아닌 JSP의 주석을 따라간다 -->
  <!-- JSP 파일에서, HTML 주석 안에 ${ }만 작성하면 실제로 오류 출력됨 -->

	<!-- model은 request scope 안에 있는 객체 -->
	<ul>
	 	<li>이름: ${myName}</li> <!-- 백승전 -->
	 	<li>나이: ${myAge}</li> <!-- 100 -->
	</ul>
</body>
</html>
```

URL 접속 시 다음과 같이 출력됩니다.

## EL 

<code>EL</code>은 Expression Language의 약자로, JSP 표현식과 비슷하며, JSP 2.0 spec 안에 포함돼 있습니다. <code>SP의 JSP Expression</code>J(<%= %>)이나 <code>JJSTL, JSP Scriptlet</code>J(<% %>) 대신 사용합니다.

사용은 다음과 같습니다.

```jsp
<!-- 모델의 key 값이 myName이면, 지금처럼 key값만 가져오면 된다 -->
${myName}
```

<code>pageScope</code> -> <code>requestScope</code> -> <code>seesionScope</code> -> <code>applicationScope</code> 순으로 스코프란 공간을 돌며 모델 객체를 찾아서 값을 찍습니다.

### Scope들의 대표 객체
- pageScope
  - page Context 객체
- requestScope
  - request
  - model
    - 모델 객체가 request scope를 가짐
- sessionScope
  - Session
- applicationScope
  - Servlet Context

<code>EL</code>은 스코프를 명시할 수 있습니다. 만약 찾고자 하는 값이 상위 스코프에 걸려 원하는 값을 가져오지 못할 수 있기 때문에, 스코프를 명시하면 명시한 영역 내에서만 확인하고, 명시하지 않으면 맨 처음에 값이 나올 때까지 모든 스코프를 돌며 찾습니다. 참고로 모델 객체는 <code>requestScope</code> 객체입니다.

### EL의 표현법, 연산, 내장 객체에 대해 알아보자

### 내장 객체
1. pageScope
2. requestScope
3. sessionScope
4. applicationScope
> 1~4번은 해당 스코프를 access 할 때 사용하는 내장 객체

5. param
  - 클라이언트 request parameter의 이름과 값을 가지고 있는 내장 객체
6. header
  - 클라이언트 request header 정보
7. cookie

### sample01/TestController08

```html
<!-- testController08.html -->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>

<body>
	<h1>EL 예제</h1>
  <!-- 입력폼을 한 개 가지고 있으며, 이름과 나이를 입력할 수 있다 -->
	<form action="/springweb/testController08/userEL" method="POST">
		이름: <input type="text" name="userName" /> <!-- 이름 입력폼 -->
		<br><br>
		나이: <input type="number" name="userAge" /> <!-- 나이 입력폼 -->
		<br><br>
		<input type="submit" value="서버로 전송" /> <!-- 클릭 시 서버로 전송 -->
	</form>
</body>
</html>
```

```java
// TestController08.java

package my.spring.springweb.sample01;

import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

import my.spring.springweb.sample01.vo.User;

@Controller
@RequestMapping(value = "/testController08")
public class TestController08 {
	private static final Logger logger = LoggerFactory.getLogger(TestController08.class);

	// HTML에서 POST로 넘기기 때문에 어노테이션을 PostMapping으로 잡음
	@PostMapping("userEL") // value 값 넣기
	public String myMethod(Model model) {
		
    // map 형태의 모델 객체
    // 모델에 여러가지 예제를 입력해보고 출력해 볼 예정

    // 1. 객체
		model.addAttribute("myName", "백승전");
		model.addAttribute("myAge", 27);
		
    // 2. 리스트
		List<String> list = new ArrayList<String>();
		list.add("손석구");
		list.add("유아인");
		model.addAttribute("myList", list);
		
    // 3. User VO
		User user = new User("백승전", 200);
		model.addAttribute("myUser", user);
		
		return "sample01/testController08";
	}
}
```

```jsp
<!-- testController08.jsp -->


```