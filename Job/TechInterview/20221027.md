## Today I Learned

<code>쿠키 </code> <code>세션</code> <code>웹 스토리지</code> <code>useMemo</code> <code>useEffect</code>

---

## 쿠키 vs 세션 vs 웹 스토리지

### 인증

> HTTP를 통해 api 요청에 대해 사용자의 권한 확인 및 접근을 제한하는 역할

쿠키와 세션, 웹 스토리지가 무엇인지 알기 전에 인증에 대해서도 알아봤습니다. 이러한 인증이 필요한 이유는, 현재 웹과 앱 서비스에서 가장 많이 쓰이는 통신 방식인 HTTP 통신은 
응답 후 연결을 끊고 과거에 대한 정보를 전혀 담지 않았습니다. 이 말인 즉슨 지금 보낼 HTTP 요청은 지난 번 HTTP 요청과 전혀 관계가 없다는 것이고,
각각의 HTTP 요청에는 주체가 누구인지에 대한 정보가 필수가 되어버린 것이죠.

그리고 이러한 인증의 수단들이 다음과 같습니다.

### 쿠키

> 웹 브라우저에 쿠키를 저장하여 HTTP 요청 시 쿠키를 헤더에 추가해서 보내는 방식

쿠키를 사용하는 이유는 HTTP 요청은 상태를 가지고 있지 않기 때문인데요.(Stateless) 다시 말해 브라우저에서는 서버에 요청을 보낼 때 그 요청 자체로는
그 요청이 누구에게서 오는지 알 수가 없는데 쿠키에 정보를 담아서 보낸다면 서버는 쿠키를 통해 파악할 수 있게 됩니다.

예를 들어 과거에는 쇼핑몰에서 로그인을 해야 장바구니에 정보가 저장되었다면, 요즘의 쇼핑몰은 로그인을 하지 않은 상태에서도 일정 기간 쿠키를 통해 정보를 유지할 수 있게 되었다는 것입니다.
쿠키는 주로 세션 관리를 통해 **로그인과 일정 접속 시간의 장바구니 등에 활용**되기도 하고, 쿠키를 통해 **사용자 별로 다른 정보를 표시**하는 등 <code>개인화</code>가 가능하며,
사용자의 행동과 패턴을 분석할 수 있기 때문에 요즘에는 더 중요한 개념이 되었습니다.

쿠키를 사용하기 위해서는 <code>Set-Cookie:키=값</code> 옵션을 사용합니다. 이것은 서버에서 클라이언트한테 **쿠키를 저장하라고 요청하는 것**입니다.
만약에 <code>Set-Cookie:name=kante</code>면 <code>name</code>이라는 키에 <code>kante</code>라는 값을 저장해서 보내는 것입니다.

쿠키의 단점이라고 하면 장기간 유지되면서 브라우저 종료 후에도 유지되는 <code>Persistent Cookie</code>의 경우 사용자의 하드디스크에 저장됩니다.
이렇게 되면 공공 PC의 경우는 쿠키를 탈취하여 개인정보를 빼돌릴 가능성도 존재해 이러한 보안상 취약점이 있고, 네트워크를 통해 암호화되지 않는 쿠키를 전송할 때는 쿠키 정보를 탈취하는 스니핑 공격에도 당할 수 있는 등 대표적으로 보안상 취약점이 가장 큰 단점으로 뽑힙니다. 이 외에도 쿠키의 용량이 <code>약 4Kb</code>로 작거나 매 HTTP 요청마다 API 호출로 인한 서버의 부담을 꼽을 수 있습니다.

### 세션

> Session ID를 식별자로, 데이터를 사용자 브라우저의 쿠키가 아닌 접속한 서버에 정보를 저장하는 방식

쿠키와 자주 비교되며 언급되는 인증 수단입니다. 세션의 경우 사용자가 접속 시 식별을 위한 <code>Session ID</code>를 생성하고 이를 메모리에 유저 정보와 함께 저장을 합니다. 그리고 이후 브라우저가 종료되면 사라지기 때문에, 쿠키의 보안상 취약점을 해결하고자 사용되었습니다.

하지만 서버에서 세션 저장소를 사용해 서버에 추가적인 저장 공간을 필요로 하기 때문에 **서버에 부하가 커진다는 단점**이 존재합니다. 그래서 유저의 수가 늘어날 경우 서버나 DB 성능에 큰 무리를 줄 수 있어 사용에 유의해야 합니다.

### 웹 스토리지

HTML5에는 데이터를 클라이언트에 저장할 수 있는 자료 구조인 웹 스토리지 스펙이 포함되어 있습니다. 웹 스토리지는 <code>키: 값(key: value)</code> 형태로 데이터를 저장해서
key를 기준으로 조회하는 패턴입니다. 그리고 여기서 <code>영구 저장소(Local Storage)</code>와 <code>임시 저장소(Session Storage)</code>를 따로 두어 데이터의 지속성을
구분할 수 있기 때문에 환경에 맞게 선택하여 사용할 수 있습니다.

이처럼 웹 환경에서 앞서 말한 쿠키와 매우 유사하지만 쿠키의 단점을 극복하는 개선점 등이 추가되어 사용합니다. 그럼에도 여전히 웹 환경에서 쿠키는 유효하고 많이 쓰이고 있기 때문에 웹 스토리지의 등장이
절대 쿠키를 사용하지 않는다는 의미는 아니라고 합니다.

### 쿠키 vs 웹 스토리지

<table>
  <th>종류</th>
  <th>데이터 전송</th>
  <th>저장 정보</th>
  <th>용량 제한</th>
  <th>데이터 저장 기간</th>
  <tr>
    <td>쿠키</td>
    <td>모든 웹 요청 서버 전송</td>
    <td>문자열</td>
    <td>4Kb</td>
    <td>만료일 존재(Persistent Cookie 사용 시 연장 가능)</td>
  </tr>
  <tr>
    <td>웹 스토리지</td>
    <td>클라이언트에 저장 및 서버 전송 x</td>
    <td>문자열 외 객체</td>
    <td>5Mb</td>
    <td>영구적인 보관 가능</td>
  </tr>
</table>

### 로컬 스토리지

명시적으로 데이터를 지우지 않으면 영구적인 보관이 가능하다. Window 전역 객체인 <code>LocalStorage</code> 컬렉션을 통해 저장과 조회, 삭제가 가능합니다.

### 세션 스토리지

데이터의 지속성과 액세스 범위에 특수한 제한이 존재하는 저장소입니다. window 전역 객체인 <code>sessionStorage</code>를 통해 저장과 조회가 이루어집니다.
데이터 유지 측면에서는 지속적으로 보관되지 않기 때문에 세션 쿠키와 성질이 비슷한데, 현재 페이지가 **브라우징 되고 있는 브라우저 컨텍스트 내에서만 데이터가 유지**된다. 때문에 브라우저를 종료하고
다시 켜면 사라집니다.

그리고 세션 스토리지도 도메인 단위로 생성이 되는데요. 게다가 같은 도메인이라도 웹 브라우저가 다를 경우, 별개의 영역이 생성이 됩니다. 그 이유는 **브라우저 컨텍스트가 다르기 때문**입니다.
다시 말해 같은 브라우저라도 탭을 추가해서 같은 페이지를 접속해도 별개의 세션 스토리지가 생성됩니다.

---

## useMemo vs useCallback

개발을 하면서 비슷한 성격의 메서드나 hook을 사용할 때 둘의 차이점, 그리고 알고 사용하는 것이 굉장히 중요하다 생각합니다. 물론 이러한 부분은 정말 많이 해 보면 느는 부분이지만요.
최근에 면접을 통해 해당 질문에 대해 속 시원한 답을 하지 못했고, 복기하고자 둘의 차이점에 대해 알아보기로 하였습니다.

(해당 내용은 면접 스터디를 위해 작성하는 글이므로, useMemo와 useCallback에 대한 코드 및 이미지를 첨부하지 않았습니다.)

### 리렌더링

리액트에서 리렌더링이 일어나는 경우는 다음과 같습니다.

- 자신의 state가 변경되었을 때
- 부모 컴포넌트로부터 전달 받은 props가 변경될 때
- 부모 컴포넌트가 리렌더링 될 때

```js
// App.js의 자식 컴포넌트 Button.js

function Button(){
  return(
    <>
      <button> Click </button>
    <>
  )
}

export default Button;
```

리액트에서는 이처럼 항상 같은 값을 return 하는 컴포넌트도 부모 컴포넌트가 리렌더링 되면서 같이 불필요한 리렌더링이 일어나게 됩니다. 그리고 이러한 리렌더링은 <code>React.memo</code>를 사용하여 
불필요한 리렌더링을 막을 수 있습니다.

### React.memo

React.memo는 컴포넌트를 <code>메모이제이션</code>해 줍니다. 부모 컴포넌트로 넘겨 받는 props가 같다면 메모이제이션 해 둔 렌더링 결과를 가져오는 건데요. 메모이제이션 한 결과를 재사용 하여 렌더링 시 가상 DOM에서 달라진 부분을 확인하지 않아 성능상에 이점이 생기게 됩니다.

```js
// App.js의 자식 컴포넌트 Button.js

function Button(){
  return(
    <>
      <button> Click </button>
    <>
  )
}

export default React.memo(Button);
```

그런데 실제로 해당 버튼에 부모 컴포넌트인 <code>App.js</code>에서 <code>onClick</code> 함수를 만들어 자식 컴포넌트인 <code>Button.js</code>에 넘겨줄 시, 당연히 버튼은 동작하지만,
이때 또 다시 리렌더링이 되는 현상을 발견할 수 있습니다.

그 이유는 리렌더링 발생 시 해당 컴포넌트의 모든 객체들이 다시 생성이 되는데, JavaScript에서는 객체는 참조 타입으로 완전히 동일한 값을 가지고 있어도 참조하는 주소가 다르면 서로 다른 객체로 취급하기 때문입니다.

```js
const a = {a: 1, b: 2};
const b = a;

a === b // true
a === {a: 1, b: 2} // false
```

b는 a의 주소값을 복사하였기 때문에 동일한 객체로 인식하지만, a와 값이 완벽히 일치하는 객체는 a와 주소값이 달라 다른 객체로 판단합니다. 따라서 컴포넌트가 리렌더링 될 때마다 **새로운 함수를 계속 생성하며(함수도 객체이기 때문)** 부모 컴포넌트로부터 넘겨 받은 props가 변경되었다 생각하고 리렌더링이 발생하는 것입니다.

즉, 부모 컴포넌트의 리렌더링으로 인한 자식 컴포넌트의 리렌더링을 <code>React.memo</code>로 막을 수 있었지만, props 변경 시 다시 리렌더링이 되는 문제가 야기되는 것이고, 이러한 점을 개선하고자 <code>useMemo</code>와 <code>useCallback</code>를 사용하는 것입니다.

#### useMemo

> 메모이제이션 된 값을 반환합니다.

```js
useMemo(param => v, [deps])
```

### useCallback

> 메모이제이션 된 함수를 반환합니다.

```js
useCallback(fn, [deps])
```

비슷하면서도 다른 둘의 차이점이라고 하면 앞서 말한 대로 <code>useMemo</code>는 의존성 배열의 값의 변경을 감지하여 캐싱된 값을 메모이제이션 하여 반환해주는 반면,
<code>useCallback</code>은 의존성 배열의 값의 변경을 감지하여 캐싱된 함수 자체를 차이입니다. 

이처럼 이론만 알고 간다면 적절한 상황에서 알맞은 사용이 가능한데요. 면접 준비용으로만 그치지 않고 직접 사용하여 실전 능력도 키울 필요가 있어 보입니다.

---

## 참고

https://ykss.netlify.app/web/storage_session_cookie/

https://leego.tistory.com/entry/React-useCallback%EA%B3%BC-useMemo-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0#:~:text=useCallback%20%EA%B3